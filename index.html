<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Wallet BIP39/BIP44 — Completa</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0f19; --card1:#1e2538; --card2:#111827; --muted:#9aa4bf; --accent1:#4f8bff; --accent2:#2f6bff;
      --danger:#ff6b6b; --success:#7ee787; --text:#ffffff; --btn-height:52px;
      --font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:var(--font-family);}
    body{display:flex;justify-content:center;align-items:flex-start;padding:18px;box-sizing:border-box;}
    .app{width:100%;max-width:720px;padding:14px;box-sizing:border-box;position:relative;min-height:92vh;}

    h1,h2,h3{margin:12px 0;text-align:center;font-weight:700;font-size:18px;}
    .muted{color:var(--muted);font-size:13px;}

    .btn{width:100%;padding:0 16px;height:var(--btn-height);border-radius:12px;border:none;font-size:15px;font-weight:600;cursor:pointer;background:linear-gradient(135deg,var(--accent1),var(--accent2));color:#fff;display:inline-flex;align-items:center;justify-content:center;}
    .btn.secondary{background:#1a1f2e;color:#fff;}
    .btn.ghost{background:transparent;border:1px solid #2a3145;color:var(--text);}
    .btn.small{width:auto;padding:8px 12px;height:36px;border-radius:10px;font-size:13px;}
    .btn:active{transform:scale(0.99);}
    .btn[disabled]{opacity:0.45;cursor:not-allowed;transform:none;}

    .screen{display:none;} .screen.active{display:block;}

    .field{margin:12px 0;}
    .field label{display:block;margin-bottom:6px;font-size:13px;opacity:0.85;}
    .field input, .field textarea, .field select{width:100%;padding:12px;border-radius:10px;border:1px solid #2a3145;background:#0f1724;color:var(--text);box-sizing:border-box;font-size:14px;outline:none;}
    .field textarea{min-height:80px;resize:none;overflow:auto;}
    .field input[type="password"]{-webkit-text-security:disc;}

    .wallet-card{background:linear-gradient(135deg,var(--card1),var(--card2));padding:16px;border-radius:14px;margin-bottom:14px;border:1px solid #2a3145;box-shadow:0 6px 20px rgba(0,0,0,0.35);}
    .balance-big{font-size:20px;font-weight:700;display:flex;align-items:center;gap:8px;}
    .balance-eth-line{font-size:18px;color:#fff;margin-top:6px;font-weight:700;display:flex;align-items:center;gap:8px;}
    .balance-usd-line{font-size:14px;color:var(--muted);margin-top:6px;display:flex;justify-content:space-between;align-items:center;gap:8px;}
    .fee-small{font-size:13px;color:#fff;margin-top:10px;word-break:break-all;}

    .small-muted{font-size:12px;color:var(--muted);margin-top:6px;}

    .amount-field{position:relative;}
    .amount-field .all-text{position:absolute;right:12px;top:50%;transform:translateY(-50%);font-size:13px;color:var(--accent1);background:transparent;border:none;cursor:pointer;padding:6px 8px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;height:calc(100% - 16px);line-height:1;}

    .reveal-box{background:#071022;border:1px solid #263044;padding:12px;border-radius:10px;color:#fff;text-align:left;}
    .reveal-value{font-family:monospace;font-size:15px;margin:8px 0;cursor:pointer;user-select:text;}
    .reveal-value.mnemonic{white-space:pre-wrap;text-align:left;word-break:normal;overflow-wrap:break-word;line-height:1.45;}
    .reveal-value.privkey{white-space:pre-wrap;text-align:left;word-break:break-all;overflow-wrap:break-word;line-height:1.45;}
    .countdown{font-size:13px;color:var(--muted);margin-top:6px;text-align:center;}

    .saved-list{margin-top:12px;display:flex;flex-direction:column;gap:8px;max-height:220px;overflow:auto;padding-right:6px;}
    .saved-item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px;border-radius:10px;background:#0e1624;border:1px solid #1f2535;}
    .saved-address{font-weight:700;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:220px;}
    .saved-date{font-size:12px;opacity:0.7;}

    .modal-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9000;padding:12px;}
    .modal{width:100%;max-width:720px;background:linear-gradient(180deg,#0f1724,#0b1220);border-radius:14px;padding:14px;border:1px solid #263044;box-shadow:0 10px 40px rgba(0,0,0,0.6);max-height:90vh;overflow:auto;}

    #modal-password, #modal-unlock { z-index: 20000 !important; }

    .backdrop-blur{background:rgba(11,15,25,0.45);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);}
    .backdrop-solid{background:rgba(11,15,25,0.95);}

    .checkbox-row{display:flex;align-items:center;gap:8px;margin-top:8px;}
    .error{color:var(--danger);font-size:13px;margin-top:6px;}
    .toast-container{position:fixed;top:14px;right:14px;z-index:1100;display:flex;flex-direction:column;gap:8px;align-items:flex-end;}
    .toast{min-width:220px;padding:10px 12px;border-radius:10px;color:#fff;font-size:14px;}
    .toast.info{background:#1f2937;border:1px solid #2a3145;}
    .toast.success{background:linear-gradient(90deg,#0f7a3a,#0bb06a);}
    .toast.error{background:linear-gradient(90deg,#ff6b6b,#ff4b4b);}

    #home-buttons { display:flex; flex-direction:column; gap:8px; }
    .qr-center { display:flex; justify-content:center; align-items:center; }

    .loading-modal .modal { background: transparent; border: none; box-shadow: none; padding: 0; max-width: 420px; width: 100%; display:flex; flex-direction:column; align-items:center; gap:12px; }
    .loading-steps { color:#fff; font-weight:700; text-align:center; font-size:16px; min-height:22px; }
    .loading-bar-outer { width:420px; height:14px; background:transparent; border-radius:10px; overflow:hidden; border:1px solid rgba(255,255,255,0.08); }
    .loading-bar-fill { height:100%; width:0%; background:linear-gradient(90deg,var(--accent1),var(--accent2)); transition:width 0.12s linear; border-radius:8px; }

    .rpc-list { margin-top:12px; display:flex; flex-direction:column; gap:8px; max-height:220px; overflow:auto; padding-right:6px; }
    .rpc-item { display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; border-radius:8px; background:#071022; border:1px solid #263044; color:#fff; font-family:monospace; font-size:13px; }
    .rpc-item .rpc-text { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:86%; }
    .rpc-item .rpc-remove { color:#ff6b6b; background:transparent; border:none; cursor:pointer; font-weight:700; font-size:14px; }

    .tx-list { margin-top:12px; display:flex; flex-direction:column; gap:6px; max-height:360px; overflow:auto; padding-right:6px; }
    .tx-item { padding:8px;border-radius:8px;background:#071022;border:1px solid #263044;color:#fff;font-size:12px;font-family:monospace; display:flex;flex-direction:column;gap:6px; cursor:pointer; }
    .tx-item:hover { box-shadow: 0 6px 18px rgba(0,0,0,0.45); transform: translateY(-1px); }
    .tx-item .tx-row { display:flex;justify-content:space-between;gap:8px;align-items:center; }
    .tx-hash { font-weight:700; font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:100%; }
    .tx-meta { color:var(--muted); font-size:11px; display:flex; justify-content:space-between; gap:8px; flex-wrap:wrap; align-items:center; }
    .tx-status { font-weight:700; font-size:12px; padding:4px 8px; border-radius:8px; }
    .tx-status.pending { background:#2a3145; color:#fff; }
    .tx-status.confirmed { background:linear-gradient(90deg,#0f7a3a,#0bb06a); color:#fff; }
    .tx-status.failed { background:linear-gradient(90deg,#ff6b6b,#ff4b4b); color:#fff; }

    #modal-tx-detail .modal { max-width:720px; padding:12px; }
    .tx-detail-row { display:flex; flex-direction:column; gap:8px; font-family:monospace; font-size:13px; color:#fff; }
    .tx-detail-row .label { color:var(--muted); font-size:12px; }
    .tx-detail-row .value { word-break:break-all; overflow-wrap:anywhere; max-width:100%; }
    .tx-detail-close { margin-top:12px; display:flex; justify-content:center; }

    @media (max-width:720px){ .loading-bar-outer{width:320px;} .app{padding:10px;} }
    @media (max-width:420px){:root{--btn-height:48px;} .modal{padding:12px;} .balance-big{font-size:18px;} .balance-eth-line{font-size:16px;} .balance-usd-line{font-size:13px;} .loading-bar-outer{width:260px;} }
  </style>
</head>
<body>
<div class="app" id="app-root">

  <!-- HOME -->
  <div id="screen-home" class="screen active">
    <h1>Wallet BIP39 / BIP44</h1>
    <p class="muted" style="text-align:center;">Derivación m/44'/60'/0'/0/0 (ETH)</p>
    <div id="home-buttons">
      <button id="btn-create" class="btn">Crear wallet</button>
      <button id="btn-import" class="btn secondary">Importar / Recuperar</button>
    </div>
  </div>

  <!-- IMPORT -->
  <div id="screen-import" class="screen">
    <h2>Importar wallet</h2>
    <div class="field">
      <label>Mnemónica (12–24 palabras) o llave privada (64 hex)</label>
      <textarea id="import-box" spellcheck="false" autocomplete="off"></textarea>
    </div>

    <div class="checkbox-row" style="margin-top:6px;">
      <label style="display:flex;align-items:center;gap:8px;">
        <input id="import-save-checkbox" type="checkbox" /> Guardar sesión
      </label>
    </div>

    <div id="import-save-fields" style="display:none; margin-top:8px;">
      <div class="field">
        <label>Contraseña para guardar</label>
        <input id="import-save-pass" type="password" placeholder="Contraseña" />
      </div>
      <div class="field">
        <label>Confirmar contraseña</label>
        <input id="import-save-pass-confirm" type="password" placeholder="Repite la contraseña" />
      </div>
      <div id="import-save-error" class="error"></div>
    </div>

    <div style="display:flex;gap:8px;">
      <button id="btn-import-confirm" class="btn">Continuar</button>
      <button id="btn-import-back" class="btn secondary">Volver</button>
    </div>

    <div style="margin-top:14px;">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div style="font-weight:700;">Wallets guardadas</div>
        <div id="saved-count" class="muted">0</div>
      </div>
      <div class="saved-list" id="saved-list"></div>
      <div id="saved-empty" class="muted" style="margin-top:10px;">No hay wallets guardadas</div>
    </div>
  </div>

  <!-- WALLET -->
  <div id="screen-wallet" class="screen">
    <div class="wallet-card">
      <div style="display:flex;flex-direction:column;gap:6px;">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;">
          <div>
            <div class="balance-big">
              <div>
                <div style="display:flex;align-items:center;gap:10px;">
                  <div class="balance-eth-line" id="wallet-balance-eth-line">0.000000000000000000 ETH</div>
                </div>
                <div class="balance-usd-line">
                  <div id="wallet-balance-usd-line">$0.00 USD</div>
                  <div id="wallet-available" style="font-size:13px;color:var(--muted);">Disponible: 0 ETH</div>
                </div>
              </div>
            </div>
          </div>
          <div style="display:flex;align-items:center;">
            <button id="btn-refresh-balance" class="btn small" style="height:36px;padding:6px 10px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent1);">
              ⟳
            </button>
          </div>
        </div>
        <div class="fee-small" id="network-fee">Fee estimado: 0.000000000000000000 ETH</div>
      </div>
    </div>

    <div style="display:flex;gap:8px;margin-bottom:6px;align-items:flex-start;">
      <div style="flex:1;"><button id="btn-open-send" class="btn">Enviar</button></div>
      <div style="width:48%;"><button id="btn-open-receive" class="btn secondary">Recibir</button></div>
    </div>

    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px;">
      <button id="btn-show-mnemonic" class="btn ghost" style="display:none;">Mostrar frase de recuperación</button>
      <button id="btn-show-privkey" class="btn ghost" style="display:none;">Mostrar llave privada</button>
      <button id="btn-change-password" class="btn ghost" style="display:none;">Cambiar contraseña</button>
      <button id="btn-rpcs" class="btn ghost" style="display:none;">RPCs personalizados</button>
    </div>

    <div style="display:flex;gap:8px;margin-top:12px;">
      <button id="btn-save-session" class="btn ghost">Guardar sesión</button>
      <button id="btn-delete-session-wallet" class="btn ghost secondary" disabled>Eliminar sesión</button>
    </div>

    <div style="margin-top:12px;">
      <button id="btn-wallet-back" class="btn secondary">Cerrar wallet</button>
    </div>

    <div style="margin-top:12px;">
      <h3 style="margin:10px 0 6px 0;">Historial de transacciones</h3>
      <div class="tx-list" id="tx-list"></div>
      <div id="tx-empty" class="muted" style="margin-top:8px;">No hay transacciones</div>
    </div>
  </div>

  <!-- Receive modal -->
  <div id="modal-receive" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Recibir ETH</h3>
      <p class="muted">Escanea el QR o copia la dirección para recibir fondos</p>
      <div class="qr-center" style="margin-top:8px;">
        <canvas id="qr-canvas" class="qr-canvas" width="220" height="220" style="background:#fff;border-radius:8px;"></canvas>
      </div>
      <div id="receive-address" class="muted" style="text-align:center;margin-top:8px;color:#fff;word-break:break-all;">0x0000000000000000000000000000000000000000</div>
      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="btn-copy-address" class="btn">Copiar address</button>
      </div>
      <div style="margin-top:12px;">
        <button id="btn-close-receive" class="btn ghost">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- Incoming notification modal -->
  <div id="modal-incoming" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Has recibido fondos</h3>
      <div style="margin-top:8px;color:#fff;">
        <div><strong>Monto:</strong> <span id="incoming-amount"></span> ETH</div>
        <div style="margin-top:6px;"><strong>Desde:</strong> <span id="incoming-from" style="font-family:monospace;"></span></div>
      </div>
      <div style="margin-top:12px;">
        <button id="incoming-close" class="btn">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- Send modal -->
  <div id="modal-send" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Enviar ETH</h3>
      <p class="muted">Completa los datos para enviar fondos</p>

      <div class="field">
        <label>Enviar a</label>
        <input id="modal-send-to" placeholder="Dirección destino" />
      </div>

      <div class="field amount-field">
        <label>Monto (ETH)</label>
        <input id="modal-send-amount" placeholder="0.000000000000000000" />
        <button id="modal-amount-all" class="all-text" title="Usar todo el saldo disponible" aria-label="Todo">Todo</button>
      </div>

      <div class="balance-usd-line" style="margin-top:6px;">
        <div id="modal-amount-usd" class="small-muted">Valor en USD: $0.00</div>
        <div id="modal-available" style="font-size:13px;color:var(--muted);">Disponible: 0 ETH</div>
      </div>

      <div id="modal-send-error" class="error"></div>

      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="modal-send-confirm" class="btn">Confirmar envío</button>
        <button id="modal-send-cancel" class="btn secondary">Cancelar</button>
      </div>
    </div>
  </div>

  <!-- Password modal -->
  <div id="modal-password" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3 id="modal-password-title">Contraseña de la sesión</h3>
      <p class="muted" id="modal-password-desc">Ingresa la contraseña de la sesión</p>

      <div id="modal-pass-single" class="field">
        <input id="modal-pass-input" type="password" placeholder="Contraseña" autocomplete="new-password" />
      </div>

      <div id="modal-pass-double" style="display:none;">
        <div class="field"><input id="modal-pass-new" type="password" placeholder="Contraseña" autocomplete="new-password" /></div>
        <div class="field"><input id="modal-pass-new-confirm" type="password" placeholder="Confirmar contraseña" autocomplete="new-password" /></div>
      </div>

      <div class="checkbox-row">
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="modal-show-password" type="checkbox" /> Mostrar contraseña
        </label>
      </div>

      <div id="modal-pass-error" class="error" style="margin-top:8px;"></div>

      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="modal-pass-confirm" class="btn">Aceptar</button>
        <button id="modal-pass-cancel" class="btn secondary">Cancelar</button>
      </div>
    </div>
  </div>

  <!-- Change password modal -->
  <div id="modal-change-password" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Cambiar contraseña</h3>
      <p class="muted">Cambia la contraseña actual (bloqueo y guardado de sesión)</p>

      <div class="field">
        <label>Contraseña actual</label>
        <input id="change-current-pass" type="password" placeholder="Contraseña actual" autocomplete="current-password" />
      </div>

      <div class="field">
        <label>Nueva contraseña</label>
        <input id="change-new-pass" type="password" placeholder="Nueva contraseña" autocomplete="new-password" />
      </div>

      <div class="field">
        <label>Confirmar nueva contraseña</label>
        <input id="change-new-pass-confirm" type="password" placeholder="Confirmar nueva contraseña" autocomplete="new-password" />
      </div>

      <div class="checkbox-row">
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="change-show-password" type="checkbox" /> Mostrar contraseña
        </label>
      </div>

      <div id="change-pass-error" class="error" style="margin-top:8px;"></div>

      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="change-pass-confirm" class="btn">Confirmar</button>
        <button id="change-pass-cancel" class="btn secondary">Cancelar</button>
      </div>
    </div>
  </div>

  <!-- RPCs modal -->
  <div id="modal-rpcs" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>RPCs personalizados</h3>
      <p class="muted">Introduce RPCs separados por coma o punto y coma</p>

      <div class="field">
        <input id="rpcs-input" placeholder="https://rpc1...eth.com, https://rpc2...eth.com" />
      </div>

      <div style="display:flex;gap:8px;">
        <button id="rpcs-add" class="btn small" style="width:auto;">Adicionar</button>
        <button id="rpcs-clear" class="btn small secondary" style="width:auto;">Limpiar</button>
        <div style="flex:1"></div>
        <button id="rpcs-close" class="btn small ghost" style="width:auto;">Cerrar</button>
      </div>

      <div class="rpc-list" id="rpc-list"></div>
    </div>
  </div>

  <!-- Reveal modal -->
  <div id="modal-reveal" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3 id="reveal-title">Revelar</h3>
      <p class="muted" id="reveal-desc">Contenido sensible</p>
      <div class="reveal-box">
        <div id="reveal-value" class="reveal-value">****</div>
        <div id="reveal-countdown" class="countdown">Se ocultará en 60s</div>
      </div>
      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="reveal-copy" class="btn">Copiar</button>
        <button id="reveal-close" class="btn secondary">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- Confirm close -->
  <div id="modal-confirm-close" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Salir sin guardar</h3>
      <p class="muted">Esta wallet no está guardada. Puedes guardarla ahora o cerrar sin guardar. ¿Qué deseas hacer?</p>
      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="modal-save-now" class="btn">Guardar ahora</button>
        <button id="modal-close-no-save" class="btn secondary">Cerrar sin guardar</button>
      </div>
      <div style="margin-top:12px;">
        <button id="modal-close-cancel" class="btn ghost">Cancelar</button>
      </div>
    </div>
  </div>

  <!-- Unlock overlay -->
  <div id="modal-unlock" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Sesión bloqueada</h3>
      <p class="muted">La sesión está bloqueada. Ingresa la contraseña de la sesión para continuar o Salir para cerrar la sesión.</p>
      <div class="field">
        <input id="unlock-pass" type="password" placeholder="Contraseña de la sesión" autocomplete="new-password" />
      </div>
      <div class="checkbox-row">
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="unlock-show-pass" type="checkbox" /> Mostrar contraseña
        </label>
      </div>
      <div id="unlock-error" class="error"></div>
      <div style="display:flex;gap:8px;margin-top:8px;">
        <button id="unlock-confirm" class="btn">Desbloquear</button>
        <button id="unlock-cancel" class="btn secondary">Salir</button>
      </div>
    </div>
  </div>

  <!-- Save-warning modal -->
  <div id="modal-save-warning" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Guarda tu sesión</h3>
      <p class="muted">Por favor guarde la sesión para mayor seguridad de su wallet</p>
      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="save-warning-accept" class="btn">Aceptar</button>
      </div>
    </div>
  </div>

  <!-- Exit confirm from unlock -->
  <div id="modal-exit-confirm-from-unlock" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Desea salir de la sesión actual?</h3>
      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="exit-from-unlock-confirm" class="btn secondary">Confirmar</button>
        <button id="exit-from-unlock-cancel" class="btn">Cancelar</button>
      </div>
    </div>
  </div>

  <!-- Loading modal -->
  <div id="modal-loading" class="modal-overlay loading-modal" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="loading-steps" id="loading-steps-text"> </div>
      <div class="loading-bar-outer" aria-hidden="true">
        <div id="loading-bar-fill" class="loading-bar-fill"></div>
      </div>
    </div>
  </div>

  <!-- Send result modals -->
  <div id="modal-send-success" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Enviado correctamente a:</h3>
      <div id="send-success-address" style="font-family:monospace;margin-top:8px;color:#fff;word-break:break-all;"></div>
      <div style="margin-top:12px;">
        <button id="send-success-close" class="btn">Cerrar</button>
      </div>
    </div>
  </div>

  <div id="modal-send-fail" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Fallo al enviar</h3>
      <div id="send-fail-reason" style="margin-top:8px;color:#fff;word-break:break-word;"></div>
      <div style="margin-top:12px;">
        <button id="send-fail-close" class="btn">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- Transaction detail modal -->
  <div id="modal-tx-detail" class="modal-overlay" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Detalle de transacción</h3>
      <div id="tx-detail-content" class="tx-detail-row" style="margin-top:8px;"></div>
      <div class="tx-detail-close">
        <button id="tx-detail-close-btn" class="btn">Cerrar</button>
      </div>
    </div>
  </div>

  <div class="toast-container" id="toast-container" aria-live="polite"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>

<script>
/*
  Archivo completo con:
  - Envío inmediato: barra aparece al tocar Enviar, 3s visual, panel cierra al terminar.
  - Entrada pendiente en UI desde el envío; persistencia solo cuando tx confirmada.
  - RPCs personalizados, cambio de contraseña, mostrar/revelar llaves, historial con fee.
  - Optimización de gasPrice (+15%) para mejorar probabilidad de inclusión.
  - Historial guarda solo transacciones confirmadas (hash válido y bloque).
*/

document.addEventListener('DOMContentLoaded', () => {
  const STORAGE_KEY = 'wallet_sessions_encrypted_v1';
  const RPCS_KEY = 'wallet_custom_rpcs_v1';
  const TX_HISTORY_KEY = 'wallet_tx_history_v1';
  const LAST_SCANNED_KEY = 'wallet_last_scanned_block_v1';

  function showToast(typeOrText, textOrTtl, maybeTtl) {
    let type='info', text='', ttl=3500;
    if (typeof textOrTtl === 'undefined') { text = typeOrText; }
    else { type = typeOrText; text = textOrTtl; ttl = maybeTtl || 3500; }
    const container = document.getElementById('toast-container');
    const t = document.createElement('div');
    t.className = 'toast ' + (type || 'info');
    t.textContent = text;
    container.appendChild(t);
    setTimeout(()=> { t.style.opacity='0'; setTimeout(()=> t.remove(),300); }, ttl);
  }

  function b64Encode(buf) { return btoa(String.fromCharCode(...new Uint8Array(buf))); }
  function b64Decode(str) { const bin = atob(str); const arr = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i); return arr.buffer; }

  async function deriveKeyFromPassword(password, salt, iterations = 150000) {
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
    return crypto.subtle.deriveKey({ name:'PBKDF2', salt: salt, iterations: iterations, hash:'SHA-256' }, keyMaterial, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']);
  }
  async function encryptSessionObject(obj, password) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKeyFromPassword(password, salt);
    const enc = new TextEncoder();
    const data = enc.encode(JSON.stringify(obj));
    const cipher = await crypto.subtle.encrypt({ name:'AES-GCM', iv: iv }, key, data);
    return { version:1, salt: b64Encode(salt), iv: b64Encode(iv), ciphertext: b64Encode(cipher) };
  }
  async function decryptSessionObject(stored, password) {
    try {
      const salt = b64Decode(stored.salt);
      const iv = b64Decode(stored.iv);
      const cipher = b64Decode(stored.ciphertext);
      const key = await deriveKeyFromPassword(password, new Uint8Array(salt));
      const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: new Uint8Array(iv) }, key, cipher);
      const dec = new TextDecoder();
      return JSON.parse(dec.decode(plain));
    } catch (e) {
      throw new Error('Contraseña incorrecta o datos corruptos');
    }
  }

  function loadAllSessions() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    try { return JSON.parse(raw); } catch { return []; }
  }
  function saveAllSessions(arr) { localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }
  function addSessionEntry(entry) { const arr = loadAllSessions(); arr.push(entry); saveAllSessions(arr); }
  function removeSessionEntryById(id) { let arr = loadAllSessions(); arr = arr.filter(e => e.id !== id); saveAllSessions(arr); }
  function updateSessionEntry(updatedEntry) {
    const arr = loadAllSessions();
    const idx = arr.findIndex(e => e.id === updatedEntry.id);
    if (idx === -1) return false;
    arr[idx] = updatedEntry;
    saveAllSessions(arr);
    return true;
  }
  function findSessionEntryByAddress(address) {
    if (!address) return null;
    const arr = loadAllSessions();
    const lower = address.toLowerCase();
    return arr.find(e => e.address && e.address.toLowerCase() === lower) || null;
  }
  function maskAddressShort(addr) {
    if (!addr) return '';
    const a = addr.replace(/^0x/i,'');
    if (a.length < 8) return '0x' + a;
    return '0x' + a.slice(0,4) + '....' + a.slice(-4);
  }

  function loadTxHistoryMap() {
    try {
      const raw = localStorage.getItem(TX_HISTORY_KEY);
      if (!raw) return {};
      const obj = JSON.parse(raw);
      if (typeof obj !== 'object' || obj === null) return {};
      return obj;
    } catch { return {}; }
  }
  function saveTxHistoryMap(map) { localStorage.setItem(TX_HISTORY_KEY, JSON.stringify(map)); }
  function getTxHistoryForAddress(address) {
    if (!address) return [];
    const map = loadTxHistoryMap();
    const key = address.toLowerCase();
    return Array.isArray(map[key]) ? map[key] : [];
  }
  function pushTxToHistory(address, txObj) {
    if (!address) return;
    const map = loadTxHistoryMap();
    const key = address.toLowerCase();
    if (!Array.isArray(map[key])) map[key] = [];
    // only confirmed txs should be stored (txObj.status === 'confirmed')
    if (txObj.status !== 'confirmed') return;
    const existing = map[key].find(t => t.hash === txObj.hash);
    if (existing) {
      Object.assign(existing, txObj);
    } else {
      map[key].unshift(txObj);
      if (map[key].length > 500) map[key].length = 500;
    }
    saveTxHistoryMap(map);
  }

  function loadRpcs() {
    try {
      const raw = localStorage.getItem(RPCS_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      return arr;
    } catch { return []; }
  }
  function saveRpcs(arr) { localStorage.setItem(RPCS_KEY, JSON.stringify(arr)); }
  let rpcList = loadRpcs();

  let provider = null;
  let blockListenerAttached = false;
  async function testRpcLatency(url, timeout = 1000) {
    try {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      const body = JSON.stringify({ jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] });
      const t0 = performance.now();
      const res = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body, signal: controller.signal });
      const t1 = performance.now();
      clearTimeout(id);
      if (!res.ok) return Infinity;
      const j = await res.json();
      if (j && (j.result || j.error === undefined)) return Math.max(1, Math.round(t1 - t0));
      return Infinity;
    } catch (e) {
      return Infinity;
    }
  }

  async function pickBestRpcAndCreateProvider() {
    const candidates = (rpcList && rpcList.length) ? rpcList.slice() : ['https://1rpc.io/eth', 'https://rpc.ankr.com/eth'];
    const toTest = candidates.slice(0, 6);
    const tests = await Promise.all(toTest.map(u => testRpcLatency(u, 1200).then(lat => ({ url: u, lat })) ));
    tests.sort((a,b) => a.lat - b.lat);
    const best = tests.find(t => isFinite(t.lat) && t.lat < 1200) || tests[0];
    try {
      provider = new ethers.providers.JsonRpcProvider(best.url);
    } catch (e) {
      provider = new ethers.providers.JsonRpcProvider(toTest[0]);
    }
    attachBlockListener();
    return provider;
  }

  function attachBlockListener() {
    try {
      if (provider && provider.off && blockListenerAttached) {
        provider.off('block', onBlock);
      }
    } catch (e) {}
    if (provider && provider.on) {
      provider.on('block', onBlock);
      blockListenerAttached = true;
    }
  }

  async function onBlock(blockNumber) {
    if (currentWallet) {
      try {
        await loadAndRenderBalance(currentWallet.address);
        await updateNetworkFee();
      } catch (e) {}
      try {
        const block = await provider.getBlockWithTransactions(blockNumber);
        if (block && Array.isArray(block.transactions)) {
          for (const tx of block.transactions) {
            if (!tx.to) continue;
            const addrLower = currentWallet.address.toLowerCase();
            if (tx.to && tx.to.toLowerCase() === addrLower) {
              const valueEth = ethers.utils.formatUnits(tx.value || '0', 18);
              let feeStr = null;
              try {
                const receipt = await provider.getTransactionReceipt(tx.hash);
                if (receipt && receipt.gasUsed) {
                  const effective = receipt.effectiveGasPrice || receipt.gasPrice || (await provider.getGasPrice());
                  const feeWei = receipt.gasUsed.mul(effective);
                  feeStr = ethers.utils.formatUnits(feeWei, 18);
                }
              } catch (e) { feeStr = null; }
              const txObj = {
                hash: tx.hash,
                from: tx.from,
                to: tx.to,
                value: valueEth,
                blockNumber: blockNumber,
                timestamp: block.timestamp || Math.floor(Date.now()/1000),
                status: 'confirmed',
                fee: feeStr
              };
              pushTxToHistory(currentWallet.address, txObj);
              renderTxHistoryUI();
              showIncomingModal(valueEth, tx.from);
            }
          }
        }
      } catch (e) {}
    }
  }

  (async () => { await pickBestRpcAndCreateProvider(); })();

  const QR = new QRious({ element: document.createElement('canvas'), size: 220 });

  let currentWallet = null;
  let cachedBalance = ethers.constants.Zero;
  let cachedFee = ethers.constants.Zero;
  let lastEthPriceUsd = 0;
  let feePollingInterval = null;

  let sendConfirmations = 1;
  let sendWaitTimeoutMs = 60000;

  function formatEthDisplayFromBigNumber(bn) {
    try {
      if (!bn || bn.isZero()) return null;
      const full = ethers.utils.formatUnits(bn, 18);
      if (!full.includes('.')) return full + '.000000000000000000';
      const [intPart, decPartRaw] = full.split('.');
      const decPart = (decPartRaw + '0'.repeat(18)).slice(0,18);
      if (decPart[17] && decPart[17] !== '0') return intPart + '.' + decPart;
      let lastNonZero = -1;
      for (let i = decPart.length - 1; i >= 0; i--) {
        if (decPart[i] !== '0') { lastNonZero = i; break; }
      }
      if (lastNonZero === -1) return null;
      return intPart + '.' + decPart.slice(0, lastNonZero + 1);
    } catch (e) { return null; }
  }
  function formatEthDisplayFromString(amountStr) {
    try {
      if (!amountStr || isNaN(Number(amountStr))) return null;
      const parts = amountStr.split('.');
      const intPart = parts[0] || '0';
      const dec = (parts[1] || '').padEnd(18,'0').slice(0,18);
      if (dec[17] && dec[17] !== '0') return intPart + '.' + dec;
      let lastNonZero = -1;
      for (let i = dec.length - 1; i >= 0; i--) {
        if (dec[i] !== '0') { lastNonZero = i; break; }
      }
      if (lastNonZero === -1) return null;
      return intPart + '.' + dec.slice(0, lastNonZero + 1);
    } catch (e) { return null; }
  }
  async function fetchEthPriceUsd() {
    try {
      const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
      if (!res.ok) return 0;
      const j = await res.json();
      const p = j.ethereum && j.ethereum.usd ? Number(j.ethereum.usd) : 0;
      lastEthPriceUsd = p;
      return p;
    } catch (e) { return 0; }
  }

  async function updateNetworkFee() {
    try {
      const gasPrice = await provider.getGasPrice();
      const gasLimit = ethers.BigNumber.from(21000);
      const fee = gasPrice.mul(gasLimit);
      cachedFee = fee;
      const feeDisplay = formatEthDisplayFromBigNumber(fee);
      const feeEl = document.getElementById('network-fee');
      if (feeEl) feeEl.textContent = feeDisplay ? ('Fee estimado: ' + feeDisplay + ' ETH') : 'Fee estimado: 0 ETH';
    } catch (e) {
      const feeEl = document.getElementById('network-fee');
      if (feeEl) feeEl.textContent = 'Fee estimado: -';
    }
  }
  function startFeePolling() {
    if (feePollingInterval) return;
    updateNetworkFee();
    feePollingInterval = setInterval(updateNetworkFee, 30000);
  }
  function stopFeePolling() {
    if (!feePollingInterval) return;
    clearInterval(feePollingInterval);
    feePollingInterval = null;
  }

  async function loadAndRenderBalance(addr) {
    try {
      const bal = await provider.getBalance(addr);
      cachedBalance = bal;
      const ethDisplay = formatEthDisplayFromBigNumber(bal);
      const balEl = document.getElementById('wallet-balance-eth-line');
      const usdEl = document.getElementById('wallet-balance-usd-line');
      const availEl = document.getElementById('wallet-available');
      if (bal.isZero()) {
        if (balEl) balEl.textContent = '0 ETH';
        if (usdEl) usdEl.textContent = '$0.00 USD';
        if (availEl) availEl.textContent = 'Disponible: 0 ETH';
        return;
      }
      if (ethDisplay) {
        if (balEl) balEl.textContent = ethDisplay + ' ETH';
        if (availEl) availEl.textContent = 'Disponible: ' + ethDisplay + ' ETH';
      } else {
        if (balEl) balEl.textContent = '0 ETH';
        if (availEl) availEl.textContent = 'Disponible: 0 ETH';
      }
      await fetchEthPriceUsd();
      const usd = lastEthPriceUsd * Number(ethers.utils.formatUnits(bal, 18));
      if (usdEl) usdEl.textContent = '$' + usd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' USD';
    } catch (e) {
      cachedBalance = ethers.constants.Zero;
      const balEl = document.getElementById('wallet-balance-eth-line');
      const usdEl = document.getElementById('wallet-balance-usd-line');
      const availEl = document.getElementById('wallet-available');
      if (balEl) balEl.textContent = '0 ETH';
      if (usdEl) usdEl.textContent = '$0.00 USD';
      if (availEl) availEl.textContent = 'Disponible: 0 ETH';
    }
  }

  function calculateMaxSendableCachedWithBuffer() {
    try {
      if (!cachedBalance || !cachedFee) return ethers.constants.Zero;
      if (cachedBalance.lte(cachedFee)) return ethers.constants.Zero;
      return cachedBalance.sub(cachedFee);
    } catch (e) { return ethers.constants.Zero; }
  }

  function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById('screen-' + id).classList.add('active');
  }

  function renderSavedList() {
    const listEl = document.getElementById('saved-list');
    const emptyEl = document.getElementById('saved-empty');
    listEl.innerHTML = '';
    const arr = loadAllSessions();
    const countEl = document.getElementById('saved-count');
    if (countEl) countEl.textContent = arr.length + ' guardadas';
    if (!arr.length) { emptyEl.style.display = 'block'; return; }
    emptyEl.style.display = 'none';
    arr.slice().reverse().forEach(entry => {
      const item = document.createElement('div'); item.className = 'saved-item';
      const meta = document.createElement('div'); meta.style.display='flex'; meta.style.flexDirection='column';
      const addr = document.createElement('div'); addr.className = 'saved-address'; addr.textContent = maskAddressShort(entry.address || '');
      const date = document.createElement('div'); date.className = 'saved-date'; date.textContent = new Date(entry.createdAt).toLocaleString();
      meta.appendChild(addr); meta.appendChild(date);
      const actions = document.createElement('div');
      const btnRec = document.createElement('button'); btnRec.className='btn small'; btnRec.textContent='Recuperar';
      btnRec.onclick = () => openRecoverInline(entry.id);
      actions.appendChild(btnRec);
      item.appendChild(meta); item.appendChild(actions);
      listEl.appendChild(item);
    });
  }

  function renderRpcListUi() {
    const container = document.getElementById('rpc-list');
    container.innerHTML = '';
    rpcList.forEach((r, idx) => {
      const item = document.createElement('div'); item.className = 'rpc-item';
      const txt = document.createElement('div'); txt.className = 'rpc-text'; txt.textContent = r;
      const btn = document.createElement('button'); btn.className = 'rpc-remove'; btn.textContent = '✕';
      btn.onclick = async () => {
        rpcList.splice(idx,1);
        saveRpcs(rpcList);
        await pickBestRpcAndCreateProvider();
        renderRpcListUi();
        showToast('info','RPC eliminado',1500);
      };
      item.appendChild(txt); item.appendChild(btn);
      container.appendChild(item);
    });
  }

  function updateSaveButtonState() {
    const saveBtn = document.getElementById('btn-save-session');
    const deleteBtn = document.getElementById('btn-delete-session-wallet');
    const changeBtn = document.getElementById('btn-change-password');
    const rpcsBtn = document.getElementById('btn-rpcs');
    const entry = currentWallet ? findSessionEntryByAddress(currentWallet.address) : null;
    if (entry) {
      if (saveBtn) saveBtn.setAttribute('disabled','true');
      if (deleteBtn) deleteBtn.removeAttribute('disabled');
      if (changeBtn) changeBtn.style.display = 'block';
      if (rpcsBtn) rpcsBtn.style.display = 'block';
    } else {
      if (saveBtn) saveBtn.removeAttribute('disabled');
      if (deleteBtn) deleteBtn.setAttribute('disabled','true');
      if (changeBtn) changeBtn.style.display = 'none';
      if (rpcsBtn) rpcsBtn.style.display = 'none';
    }
  }

  function renderTxHistoryUI() {
    const listEl = document.getElementById('tx-list');
    const emptyEl = document.getElementById('tx-empty');
    listEl.innerHTML = '';
    if (!currentWallet) { emptyEl.style.display = 'block'; return; }
    const arr = getTxHistoryForAddress(currentWallet.address);
    if (!arr || !arr.length) { emptyEl.style.display = 'block'; return; }
    emptyEl.style.display = 'none';
    arr.forEach(tx => {
      const item = document.createElement('div'); item.className = 'tx-item';
      const date = new Date((tx.timestamp || Math.floor(Date.now()/1000)) * 1000);
      const dateStr = date.toLocaleString();
      const shortHash = tx.hash ? (tx.hash.slice(0,8) + '...' + tx.hash.slice(-6)) : '';
      const fromShort = tx.from ? maskAddressShort(tx.from) : '';
      const toShort = tx.to ? maskAddressShort(tx.to) : '';
      const status = tx.status || 'confirmed';
      const statusClass = status === 'pending' ? 'pending' : (status === 'confirmed' ? 'confirmed' : 'failed');
      const statusText = status === 'pending' ? 'Pendiente' : (status === 'confirmed' ? 'Confirmado' : 'Fallido');
      const feeDisplay = tx.fee ? (tx.fee + ' ETH') : '-';

      item.innerHTML = `
        <div class="tx-hash" title="${tx.hash || '-'}">${shortHash}</div>
        <div class="tx-row">
          <div style="flex:1;overflow:hidden;"><strong>De:</strong> ${fromShort}</div>
          <div style="flex:1;overflow:hidden;text-align:right;"><strong>A:</strong> ${toShort}</div>
        </div>
        <div class="tx-meta">
          <div><strong>${tx.value}</strong> ETH</div>
          <div>Fee: ${feeDisplay}</div>
          <div>Bloque: ${tx.blockNumber || '-'}</div>
          <div>${dateStr}</div>
          <div class="tx-status ${statusClass}">${statusText}</div>
        </div>
      `;
      item.addEventListener('click', () => openTxDetailModal(tx));
      listEl.appendChild(item);
    });
  }

  function openTxDetailModal(tx) {
    const modal = document.getElementById('modal-tx-detail');
    const content = document.getElementById('tx-detail-content');
    content.innerHTML = '';
    function row(label, value) {
      const r = document.createElement('div');
      const lab = document.createElement('div'); lab.className = 'label'; lab.textContent = label;
      const val = document.createElement('div'); val.className = 'value'; val.textContent = value || '-';
      r.appendChild(lab); r.appendChild(val);
      return r;
    }

    content.appendChild(row('Hash', tx.hash || '-'));
    content.appendChild(row('De', tx.from || '-'));
    content.appendChild(row('A', tx.to || '-'));
    content.appendChild(row('Monto', (tx.value || '0') + ' ETH'));
    content.appendChild(row('Fee usada', tx.fee ? (tx.fee + ' ETH') : '-'));
    content.appendChild(row('Bloque', tx.blockNumber || '-'));
    content.appendChild(row('Fecha / Hora', new Date((tx.timestamp||0)*1000).toLocaleString() || '-'));
    content.appendChild(row('Estado', (tx.status || 'confirmed').toUpperCase()));
    if (tx.extra) content.appendChild(row('Detalles', tx.extra));

    modal.style.display = 'flex';
    modal.classList.add('backdrop-blur');
  }

  document.getElementById('tx-detail-close-btn').addEventListener('click', () => {
    const modal = document.getElementById('modal-tx-detail');
    modal.style.display = 'none';
    modal.classList.remove('backdrop-blur','backdrop-solid');
  });

  function renderWalletUI() {
    if (!currentWallet) return;
    const addrEl = document.getElementById('receive-address');
    if (addrEl) addrEl.textContent = currentWallet.address;
    const btnMn = document.getElementById('btn-show-mnemonic');
    const btnPk = document.getElementById('btn-show-privkey');
    btnMn.style.display = currentWallet.mnemonic ? 'block' : 'none';
    btnPk.style.display = currentWallet.privateKey ? 'block' : 'none';
    loadAndRenderBalance(currentWallet.address);
    renderTxHistoryUI();
    updateSaveButtonState();
    startFeePolling();
  }

  function showLoadingModalControlled(initialText, timeoutMs) {
    const loadingModal = document.getElementById('modal-loading');
    const fill = document.getElementById('loading-bar-fill');
    const stepsText = document.getElementById('loading-steps-text');
    let stopped = false;
    let start = Date.now();
    fill.style.width = '0%';
    stepsText.textContent = initialText || '';
    loadingModal.style.display = 'flex';
    loadingModal.classList.add('backdrop-blur');
    try {
      const supports = CSS && CSS.supports && (CSS.supports('backdrop-filter','blur(1px)') || CSS.supports('-webkit-backdrop-filter','blur(1px)'));
      if (!supports) loadingModal.classList.remove('backdrop-blur'), loadingModal.classList.add('backdrop-solid');
    } catch (e) { loadingModal.classList.remove('backdrop-blur'); loadingModal.classList.add('backdrop-solid'); }

    const interval = 50;
    const timer = setInterval(() => {
      if (stopped) return;
      const elapsed = Date.now() - start;
      const pct = Math.min(99, Math.round((elapsed / timeoutMs) * 100));
      fill.style.width = pct + '%';
    }, interval);

    return {
      setText: (t) => { stepsText.textContent = t; },
      setProgress: (pct) => { fill.style.width = Math.max(0, Math.min(100, pct)) + '%'; },
      stop: () => {
        stopped = true;
        clearInterval(timer);
        fill.style.width = '100%';
        loadingModal.style.display = 'none';
        loadingModal.classList.remove('backdrop-blur','backdrop-solid');
      }
    };
  }

  // CREATE wallet
  document.getElementById('btn-create').addEventListener('click', async () => {
    const totalMs = 5000;
    const step1Ms = 1800;
    const step2Ms = 2200;
    const loadingModal = document.getElementById('modal-loading');
    const fill = document.getElementById('loading-bar-fill');
    const stepsText = document.getElementById('loading-steps-text');

    fill.style.width = '0%';
    stepsText.textContent = 'Creando wallet';

    loadingModal.style.display = 'flex';
    loadingModal.classList.add('backdrop-blur');
    try {
      const supports = CSS && CSS.supports && (CSS.supports('backdrop-filter','blur(1px)') || CSS.supports('-webkit-backdrop-filter','blur(1px)'));
      if (!supports) loadingModal.classList.remove('backdrop-blur'), loadingModal.classList.add('backdrop-solid');
    } catch (e) { loadingModal.classList.remove('backdrop-blur'); loadingModal.classList.add('backdrop-solid'); }

    const start = Date.now();
    const interval = 40;
    const timer = setInterval(() => {
      const elapsed = Date.now() - start;
      const pct = Math.min(100, Math.round((elapsed / totalMs) * 100));
      fill.style.width = pct + '%';
      if (elapsed >= totalMs) clearInterval(timer);
    }, interval);

    setTimeout(() => { stepsText.textContent = 'Cargando interface'; }, step1Ms);
    setTimeout(() => { stepsText.textContent = 'Wallet lista'; }, step1Ms + step2Ms);

    setTimeout(() => {
      loadingModal.style.display = 'none';
      loadingModal.classList.remove('backdrop-blur','backdrop-solid');
      try {
        const w = ethers.Wallet.createRandom();
        currentWallet = { address: w.address, privateKey: w.privateKey, mnemonic: w.mnemonic ? w.mnemonic.phrase : null };
        renderWalletUI();
        showScreen('wallet');
        showToast('success','Wallet creada',1800);
        renderSavedList();
      } catch (e) {
        showToast('error','Error creando wallet: ' + (e.message || e), 3500);
      }
    }, totalMs + 80);
  });

  document.getElementById('btn-import').addEventListener('click', () => {
    document.getElementById('import-box').value = '';
    document.getElementById('import-save-checkbox').checked = false;
    document.getElementById('import-save-fields').style.display = 'none';
    document.getElementById('import-save-pass').value = '';
    document.getElementById('import-save-pass-confirm').value = '';
    document.getElementById('import-save-error').textContent = '';
    showScreen('import');
    renderSavedList();
  });
  document.getElementById('btn-import-back').addEventListener('click', () => showScreen('home'));

  document.getElementById('import-save-checkbox').addEventListener('change', (e) => {
    document.getElementById('import-save-fields').style.display = e.target.checked ? 'block' : 'none';
    document.getElementById('import-save-error').textContent = '';
  });

  // Import confirm
  document.getElementById('btn-import-confirm').addEventListener('click', async () => {
    const raw = document.getElementById('import-box').value.trim();
    const err = document.getElementById('import-save-error');
    err.textContent = '';
    try {
      const hex = raw.replace(/^0x/,'');
      const isPriv = /^[0-9a-fA-F]{64}$/.test(hex);
      if (!isPriv && !ethers.utils.isValidMnemonic(raw)) throw new Error('Mnemónica o llave privada inválida');

      const loader = showLoadingModalControlled('Importando wallet.', 3000);
      await new Promise(r => setTimeout(r, 900));
      loader.setText('Importando wallet..');
      await new Promise(r => setTimeout(r, 900));
      loader.setText('Importando wallet...');
      await new Promise(r => setTimeout(r, 900));
      loader.stop();

      let wallet;
      if (isPriv) {
        wallet = new ethers.Wallet('0x' + hex);
        currentWallet = { address: wallet.address, privateKey: wallet.privateKey, mnemonic: null };
      } else {
        wallet = ethers.Wallet.fromMnemonic(raw, "m/44'/60'/0'/0/0");
        currentWallet = { address: wallet.address, privateKey: wallet.privateKey, mnemonic: raw };
      }

      if (document.getElementById('import-save-checkbox').checked) {
        const p1 = document.getElementById('import-save-pass').value;
        const p2 = document.getElementById('import-save-pass-confirm').value;
        if (!p1 || p1.length < 6) { err.textContent = 'Contraseña mínima 6 caracteres.'; throw new Error('Contraseña inválida'); }
        if (p1 !== p2) { err.textContent = 'Las contraseñas no coinciden.'; throw new Error('Contraseñas no coinciden'); }
        const payload = { address: currentWallet.address, privateKey: currentWallet.privateKey, mnemonic: currentWallet.mnemonic || null, savedAt: new Date().toISOString() };
        const encrypted = await encryptSessionObject(payload, p1);
        const entry = { id: 's_' + Date.now() + '_' + Math.floor(Math.random()*10000), address: payload.address, createdAt: payload.savedAt, stored: encrypted };
        addSessionEntry(entry);
        showToast('success','Sesión guardada durante import',2500);
      }

      renderWalletUI();
      showScreen('wallet');
      showToast('success','Wallet cargada',2200);
    } catch (e) {
      if (!document.getElementById('import-save-error').textContent) err.textContent = e.message;
      showToast('error', e.message, 3500);
    }
  });

  document.getElementById('btn-open-receive').addEventListener('click', () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',3000); return; }
    const modal = document.getElementById('modal-receive');
    const canvas = document.getElementById('qr-canvas');
    const addrEl = document.getElementById('receive-address');
    const addr = currentWallet.address;
    if (addrEl) addrEl.textContent = addr;
    QR.set({ value: addr, size: 220 });
    const dataUrl = QR.toDataURL();
    const ctx = canvas.getContext('2d');
    const img = new Image();
    img.onload = () => { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); };
    img.src = dataUrl;
    modal.style.display = 'flex';
    modal.classList.add('backdrop-blur');
  });
  document.getElementById('btn-close-receive').addEventListener('click', () => {
    const modal = document.getElementById('modal-receive'); modal.style.display='none'; modal.classList.remove('backdrop-blur','backdrop-solid');
  });
  document.getElementById('btn-copy-address').addEventListener('click', async () => {
    if (!currentWallet) return;
    try { await navigator.clipboard.writeText(currentWallet.address); showToast('success','Dirección copiada',2000); }
    catch (e) { showToast('error','No se pudo copiar',3000); }
  });

  function showIncomingModal(amount, from) {
    const modal = document.getElementById('modal-incoming');
    document.getElementById('incoming-amount').textContent = amount;
    document.getElementById('incoming-from').textContent = from;
    modal.style.display = 'flex';
    modal.classList.add('backdrop-blur');
  }
  document.getElementById('incoming-close').addEventListener('click', () => {
    const modal = document.getElementById('modal-incoming');
    modal.style.display = 'none';
    modal.classList.remove('backdrop-blur','backdrop-solid');
  });

  document.getElementById('btn-refresh-balance').addEventListener('click', async () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',2000); return; }
    try {
      await loadAndRenderBalance(currentWallet.address);
      await updateNetworkFee();
      showToast('success','Saldo actualizado',1200);
    } catch (e) {
      showToast('error','No se pudo actualizar saldo',2000);
    }
  });

  const modalSend = document.getElementById('modal-send');
  document.getElementById('btn-open-send').addEventListener('click', () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',3000); return; }
    document.getElementById('modal-send-to').value = '';
    document.getElementById('modal-send-amount').value = '';
    document.getElementById('modal-amount-usd').textContent = 'Valor en USD: $0.00';
    document.getElementById('modal-available').textContent = 'Disponible: 0 ETH';
    document.getElementById('modal-send-error').textContent = '';
    modalSend.style.display = 'flex';
    modalSend.classList.add('backdrop-blur');
    loadAndRenderBalance(currentWallet.address);
    updateNetworkFee();
    const avail = formatEthDisplayFromBigNumber(cachedBalance) || '0';
    document.getElementById('modal-available').textContent = 'Disponible: ' + avail + ' ETH';
  });

  document.getElementById('modal-send-cancel').addEventListener('click', () => {
    modalSend.style.display = 'none';
    modalSend.classList.remove('backdrop-blur','backdrop-solid');
  });

  document.getElementById('modal-amount-all').addEventListener('click', (ev) => {
    ev.preventDefault();
    if (!currentWallet) return;
    const max = calculateMaxSendableCachedWithBuffer();
    const maxStr = ethers.utils.formatUnits(max, 18);
    const final = formatEthDisplayFromString(maxStr);
    if (final) {
      document.getElementById('modal-send-amount').value = final;
      updateModalAmountUsdDisplay(final);
    } else {
      document.getElementById('modal-send-amount').value = '0';
      updateModalAmountUsdDisplay('0');
    }
  });

  document.getElementById('modal-send-amount').addEventListener('input', (e) => updateModalAmountUsdDisplay(e.target.value));
  async function updateModalAmountUsdDisplay(amountStr) {
    try {
      await fetchEthPriceUsd();
      const amt = amountStr ? Number(amountStr) : 0;
      const usd = lastEthPriceUsd * amt;
      const el = document.getElementById('modal-amount-usd');
      if (el) el.textContent = 'Valor en USD: $' + usd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      const avail = formatEthDisplayFromBigNumber(cachedBalance) || '0';
      document.getElementById('modal-available').textContent = 'Disponible: ' + avail + ' ETH';
    } catch (e) {
      const el = document.getElementById('modal-amount-usd');
      if (el) el.textContent = 'Valor en USD: $0.00';
    }
  }

  // Pending helpers
  function addPendingTxToUI(pendingTx) {
    const listEl = document.getElementById('tx-list');
    const emptyEl = document.getElementById('tx-empty');
    emptyEl.style.display = 'none';

    const item = document.createElement('div');
    item.className = 'tx-item';
    item.dataset.hash = pendingTx.hash || ('pending_' + Date.now());
    item.dataset.pending = 'true';

    const date = new Date((pendingTx.timestamp || Math.floor(Date.now()/1000)) * 1000);
    const dateStr = date.toLocaleString();
    const shortHash = pendingTx.hash ? (pendingTx.hash.slice(0,8) + '...' + pendingTx.hash.slice(-6)) : 'pendiente';

    item.innerHTML = `
      <div class="tx-hash">${shortHash}</div>
      <div class="tx-row">
        <div style="flex:1;"><strong>De:</strong> ${maskAddressShort(pendingTx.from)}</div>
        <div style="flex:1;text-align:right;"><strong>A:</strong> ${maskAddressShort(pendingTx.to)}</div>
      </div>
      <div class="tx-meta">
        <div><strong>${pendingTx.value}</strong> ETH</div>
        <div>Fee: ${pendingTx.fee ? (pendingTx.fee + ' ETH') : '-'}</div>
        <div>Bloque: -</div>
        <div>${dateStr}</div>
        <div class="tx-status pending">Pendiente</div>
      </div>
    `;
    item.addEventListener('click', () => openTxDetailModal(Object.assign({}, pendingTx, { status: 'pending' })));
    listEl.insertBefore(item, listEl.firstChild);
    return item;
  }

  function updatePendingTxUI(hash, confirmedTx) {
    const listEl = document.getElementById('tx-list');
    const items = listEl.querySelectorAll('.tx-item');
    for (const it of items) {
      if (it.dataset.hash === hash) {
        const date = new Date((confirmedTx.timestamp || Math.floor(Date.now()/1000)) * 1000);
        const dateStr = date.toLocaleString();
        const shortHash = confirmedTx.hash.slice(0,8) + '...' + confirmedTx.hash.slice(-6);
        const fromShort = maskAddressShort(confirmedTx.from);
        const toShort = maskAddressShort(confirmedTx.to);
        const feeDisplay = confirmedTx.fee ? (confirmedTx.fee + ' ETH') : '-';
        it.innerHTML = `
          <div class="tx-hash">${shortHash}</div>
          <div class="tx-row">
            <div style="flex:1;"><strong>De:</strong> ${fromShort}</div>
            <div style="flex:1;text-align:right;"><strong>A:</strong> ${toShort}</div>
          </div>
          <div class="tx-meta">
            <div><strong>${confirmedTx.value}</strong> ETH</div>
            <div>Fee: ${feeDisplay}</div>
            <div>Bloque: ${confirmedTx.blockNumber || '-'}</div>
            <div>${dateStr}</div>
            <div class="tx-status confirmed">Confirmado</div>
          </div>
        `;
        it.dataset.pending = 'false';
        it.addEventListener('click', () => openTxDetailModal(confirmedTx));
        return;
      }
    }
    renderTxHistoryUI();
  }

  // Send flow: immediate loader, close panel at end, pending UI, persist only confirmed
  document.getElementById('modal-send-confirm').addEventListener('click', async () => {
    const to = document.getElementById('modal-send-to').value.trim();
    let amountStr = document.getElementById('modal-send-amount').value.trim();
    const errEl = document.getElementById('modal-send-error');
    errEl.textContent = '';
    if (!to) { errEl.textContent = 'Ingresa una dirección destino.'; return; }
    if (!amountStr || isNaN(Number(amountStr)) || Number(amountStr) <= 0) { errEl.textContent = 'Monto inválido.'; return; }

    // loader inmediato
    const loader = showLoadingModalControlled('Enviando.', 3000);
    loader.setProgress(5);
    const fastTimer = setInterval(() => {
      const currentWidth = parseInt(document.getElementById('loading-bar-fill').style.width || '0', 10);
      const next = Math.min(100, currentWidth + 20);
      loader.setProgress(next);
      if (next >= 100) clearInterval(fastTimer);
    }, 150);
    setTimeout(() => {
      try { loader.stop(); } catch (e) {}
      const modalSend = document.getElementById('modal-send');
      modalSend.style.display = 'none';
      modalSend.classList.remove('backdrop-blur','backdrop-solid');
    }, 3000);

    try {
      await pickBestRpcAndCreateProvider();
      const amountWeiRequested = ethers.utils.parseUnits(amountStr, 18);
      const gasLimit = ethers.BigNumber.from(21000);
      let networkGasPrice = await provider.getGasPrice();
      const optimizedGasPrice = networkGasPrice.mul(115).div(100);
      let feeEstimate = optimizedGasPrice.mul(gasLimit);
      const balance = await provider.getBalance(currentWallet.address);

      if (amountWeiRequested.add(feeEstimate).gt(balance)) {
        let maxSendable = balance.sub(feeEstimate);
        if (maxSendable.lte(ethers.constants.Zero)) {
          document.getElementById('send-fail-reason').textContent = 'Fondos insuficientes';
          document.getElementById('modal-send-fail').style.display = 'flex';
          document.getElementById('modal-send-fail').classList.add('backdrop-blur');
          return;
        } else {
          amountStr = ethers.utils.formatUnits(maxSendable, 18);
        }
      }

      const wallet = new ethers.Wallet(currentWallet.privateKey, provider);
      const txRequest = { to, value: ethers.utils.parseUnits(amountStr, 18), gasLimit, gasPrice: optimizedGasPrice };
      let tx;
      try { tx = await wallet.sendTransaction(txRequest); }
      catch (e) {
        const msg = (e && e.message && /insufficient funds/i.test(e.message)) ? 'Fondos insuficientes' : 'Error al enviar';
        document.getElementById('send-fail-reason').textContent = msg;
        document.getElementById('modal-send-fail').style.display = 'flex';
        document.getElementById('modal-send-fail').classList.add('backdrop-blur');
        return;
      }

      // entrada pendiente inmediata
      const pendingTxObj = {
        hash: tx.hash,
        from: currentWallet.address,
        to,
        value: ethers.utils.formatUnits(txRequest.value, 18),
        blockNumber: null,
        timestamp: Math.floor(Date.now()/1000),
        status: 'pending',
        fee: ethers.utils.formatUnits(optimizedGasPrice.mul(gasLimit), 18)
      };
      addPendingTxToUI(pendingTxObj);

      // esperar confirmación
      (async () => {
        try {
          const receipt = await provider.waitForTransaction(tx.hash, 1, 120000).catch(()=>null);
          if (receipt && receipt.blockNumber) {
            const gasUsed = receipt.gasUsed || ethers.BigNumber.from(0);
            const effective = receipt.effectiveGasPrice || receipt.gasPrice || optimizedGasPrice;
            const feeWei = gasUsed.mul(effective);
            const feeStr = ethers.utils.formatUnits(feeWei, 18);
            const confirmedTx = {
              hash: tx.hash,
              from: currentWallet.address,
              to,
              value: ethers.utils.formatUnits(txRequest.value, 18),
              blockNumber: receipt.blockNumber,
              timestamp: Math.floor(Date.now()/1000),
              status: 'confirmed',
              fee: feeStr
            };
            pushTxToHistory(currentWallet.address, confirmedTx);
            updatePendingTxUI(tx.hash, confirmedTx);
            document.getElementById('send-success-address').textContent = to;
            document.getElementById('modal-send-success').style.display = 'flex';
            document.getElementById('modal-send-success').classList.add('backdrop-blur');
            setTimeout(() => loadAndRenderBalance(currentWallet.address).catch(()=>{}), 1200);
          } else {
            document.getElementById('send-fail-reason').textContent = 'No confirmada en tiempo';
            document.getElementById('modal-send-fail').style.display = 'flex';
            document.getElementById('modal-send-fail').classList.add('backdrop-blur');
            const listEl = document.getElementById('tx-list');
            const items = listEl.querySelectorAll('.tx-item');
            items.forEach(it => { if (it.dataset.hash === tx.hash) it.remove(); });
          }
        } catch (e) {
          document.getElementById('send-fail-reason').textContent = 'Error durante confirmación';
          document.getElementById('modal-send-fail').style.display = 'flex';
          document.getElementById('modal-send-fail').classList.add('backdrop-blur');
          const listEl = document.getElementById('tx-list');
          const items = listEl.querySelectorAll('.tx-item');
          items.forEach(it => { if (it.dataset.hash === tx.hash) it.remove(); });
        }
      })();

    } catch (e) {
      document.getElementById('send-fail-reason').textContent = 'Error de red';
      document.getElementById('modal-send-fail').style.display = 'flex';
      document.getElementById('modal-send-fail').classList.add('backdrop-blur');
    }
  });

  document.getElementById('send-success-close').addEventListener('click', () => {
    const m = document.getElementById('modal-send-success');
    m.style.display = 'none';
    m.classList.remove('backdrop-blur','backdrop-solid');
  });
  document.getElementById('send-fail-close').addEventListener('click', () => {
    const m = document.getElementById('modal-send-fail');
    m.style.display = 'none';
    m.classList.remove('backdrop-blur','backdrop-solid');
  });

  // Password modal flows
  const modalPassword = document.getElementById('modal-password');
  const modalTitle = document.getElementById('modal-password-title');
  const modalDesc = document.getElementById('modal-password-desc');
  const modalSingle = document.getElementById('modal-pass-single');
  const modalDouble = document.getElementById('modal-pass-double');
  const modalInput = document.getElementById('modal-pass-input');
  const modalNew = document.getElementById('modal-pass-new');
  const modalNewConfirm = document.getElementById('modal-pass-new-confirm');
  const modalShowPassword = document.getElementById('modal-show-password');
  const modalPassError = document.getElementById('modal-pass-error');
  const modalConfirm = document.getElementById('modal-pass-confirm');
  const modalCancel = document.getElementById('modal-pass-cancel');

  let pendingAction = null;
  let pendingSessionId = null;

  document.getElementById('btn-save-session').addEventListener('click', () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',3000); return; }
    pendingAction = 'save';
    modalTitle.textContent = 'Guardar sesión';
    modalDesc.textContent = 'Introduce una contraseña para encriptar y guardar la sesión';
    modalSingle.style.display = 'none';
    modalDouble.style.display = 'block';
    modalInput.value = ''; modalNew.value = ''; modalNewConfirm.value = ''; modalPassError.textContent = '';
    modalShowPassword.checked = false;
    modalPassword.style.display = 'flex';
    modalPassword.classList.add('backdrop-blur');
  });

  function openRecoverInline(id) {
    pendingAction = 'recover';
    pendingSessionId = id;
    modalTitle.textContent = 'Recuperar sesión';
    modalDesc.textContent = 'Introduce la contraseña de la sesión para recuperar';
    modalSingle.style.display = 'block';
    modalDouble.style.display = 'none';
    modalInput.value = ''; modalPassError.textContent = '';
    modalShowPassword.checked = false;
    modalPassword.style.display = 'flex';
    modalPassword.classList.add('backdrop-blur');
  }

  document.getElementById('btn-delete-session-wallet').addEventListener('click', () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',3000); return; }
    const entry = findSessionEntryByAddress(currentWallet.address);
    if (!entry) { showToast('error','No hay sesión guardada',3000); return; }
    pendingAction = 'delete';
    modalTitle.textContent = 'Eliminar sesión';
    modalDesc.textContent = 'Introduce la contraseña de la sesión para eliminarla';
    modalSingle.style.display = 'block';
    modalDouble.style.display = 'none';
    modalInput.value = ''; modalPassError.textContent = '';
    modalShowPassword.checked = false;
    modalPassword.style.display = 'flex';
    modalPassword.classList.add('backdrop-blur');
  });

  document.getElementById('btn-show-mnemonic').addEventListener('click', () => {
    if (!currentWallet || !currentWallet.mnemonic) { showToast('error','No hay frase disponible',3000); return; }
    const entry = findSessionEntryByAddress(currentWallet.address);
    if (!entry) { showToast('info','Debes guardar la sesión antes de revelar',3000); return; }
    pendingAction = 'reveal-mnemonic';
    modalTitle.textContent = 'Revelar frase';
    modalDesc.textContent = 'Introduce la contraseña de la sesión para mostrar la frase';
    modalSingle.style.display = 'block';
    modalDouble.style.display = 'none';
    modalInput.value = ''; modalPassError.textContent = '';
    modalShowPassword.checked = false;
    modalPassword.style.display = 'flex';
    modalPassword.classList.add('backdrop-blur');
  });

  document.getElementById('btn-show-privkey').addEventListener('click', () => {
    if (!currentWallet || !currentWallet.privateKey) { showToast('error','No hay llave privada',3000); return; }
    const entry = findSessionEntryByAddress(currentWallet.address);
    if (!entry) { showToast('info','Debes guardar la sesión antes de revelar',3000); return; }
    pendingAction = 'reveal-privkey';
    modalTitle.textContent = 'Revelar llave privada';
    modalDesc.textContent = 'Introduce la contraseña de la sesión para mostrar la llave';
    modalSingle.style.display = 'block';
    modalDouble.style.display = 'none';
    modalInput.value = ''; modalPassError.textContent = '';
    modalShowPassword.checked = false;
    modalPassword.style.display = 'flex';
    modalPassword.classList.add('backdrop-blur');
  });

  modalShowPassword.addEventListener('change', () => {
    const show = modalShowPassword.checked;
    if (modalSingle.style.display !== 'none') modalInput.type = show ? 'text' : 'password';
    if (modalDouble.style.display !== 'none') { modalNew.type = show ? 'text' : 'password'; modalNewConfirm.type = show ? 'text' : 'password'; }
  });

  modalCancel.addEventListener('click', () => {
    modalPassword.style.display = 'none';
    modalPassword.classList.remove('backdrop-blur','backdrop-solid');
    modalPassError.textContent = '';
    pendingAction = null;
    pendingSessionId = null;
  });

  modalConfirm.addEventListener('click', async () => {
    modalPassError.textContent = '';
    try {
      if (pendingAction === 'save') {
        const p1 = modalNew.value.trim();
        const p2 = modalNewConfirm.value.trim();
        if (!p1 || p1.length < 6) { modalPassError.textContent = 'Contraseña mínima 6 caracteres.'; return; }
        if (p1 !== p2) { modalPassError.textContent = 'Las contraseñas no coinciden.'; return; }
        const payload = { address: currentWallet.address, privateKey: currentWallet.privateKey, mnemonic: currentWallet.mnemonic || null, savedAt: new Date().toISOString() };
        const encrypted = await encryptSessionObject(payload, p1);
        const entry = { id: 's_' + Date.now() + '_' + Math.floor(Math.random()*10000), address: payload.address, createdAt: payload.savedAt, stored: encrypted };
        addSessionEntry(entry);
        modalPassword.style.display = 'none';
        modalPassword.classList.remove('backdrop-blur','backdrop-solid');
        showToast('success','Sesión guardada correctamente',3000);
        renderSavedList();
        updateSaveButtonState();
        pendingAction = null;
        return;
      }

      if (pendingAction === 'recover') {
        const pass = modalInput.value.trim();
        if (!pass) { modalPassError.textContent = 'Ingresa la contraseña.'; return; }
        const arr = loadAllSessions();
        const entry = arr.find(e => e.id === pendingSessionId);
        if (!entry) { modalPassError.textContent = 'Entrada no encontrada.'; return; }
        let obj;
        try { obj = await decryptSessionObject(entry.stored, pass); }
        catch (e) { modalPassError.textContent = 'Contraseña incorrecta'; return; }

        modalPassword.style.display = 'none';
        modalPassword.classList.remove('backdrop-blur','backdrop-solid');

        const loader = showLoadingModalControlled('Iniciando sesión.', 3000);
        await new Promise(r => setTimeout(r, 1200));
        loader.setText('Iniciando sesión..');
        await new Promise(r => setTimeout(r, 1200));
        loader.stop();

        currentWallet = { address: obj.address, privateKey: obj.privateKey, mnemonic: obj.mnemonic };
        showScreen('wallet');
        renderWalletUI();
        showToast('success','Wallet recuperada',3000);
        pendingAction = null;
        pendingSessionId = null;
        return;
      }

      if (pendingAction === 'delete') {
        const pass = modalInput.value.trim();
        if (!pass) { modalPassError.textContent = 'Ingresa la contraseña.'; return; }
        const entry = findSessionEntryByAddress(currentWallet.address);
        if (!entry) { modalPassError.textContent = 'No hay sesión guardada.'; return; }
        await decryptSessionObject(entry.stored, pass);
        removeSessionEntryById(entry.id);
        modalPassword.style.display = 'none';
        modalPassword.classList.remove('backdrop-blur','backdrop-solid');
        showToast('success','Sesión eliminada correctamente',3000);
        renderSavedList();
        updateSaveButtonState();
        pendingAction = null;
        return;
      }

      if (pendingAction === 'reveal-mnemonic' || pendingAction === 'reveal-privkey') {
        const pass = modalInput.value.trim();
        if (!pass) { modalPassError.textContent = 'Ingresa la contraseña.'; return; }
        const entry = findSessionEntryByAddress(currentWallet.address);
        if (!entry) { modalPassError.textContent = 'No hay sesión guardada.'; return; }
        await decryptSessionObject(entry.stored, pass);
        modalPassword.style.display = 'none';
        modalPassword.classList.remove('backdrop-blur','backdrop-solid');
        if (pendingAction === 'reveal-mnemonic') openRevealModalDirect(currentWallet.mnemonic || '(no disponible)', 'Frase de recuperación', 'No compartas esta frase con nadie', 'mnemonic');
        else openRevealModalDirect(currentWallet.privateKey || '(no disponible)', 'Llave privada', 'No compartas esta llave con nadie', 'privkey');
        pendingAction = null;
        return;
      }

      if (pendingAction === 'close-session') {
        const pass = modalInput.value.trim();
        if (!pass) { modalPassError.textContent = 'Ingresa la contraseña.'; return; }
        const entry = findSessionEntryByAddress(currentWallet.address);
        if (!entry) { modalPassError.textContent = 'No hay sesión guardada.'; return; }
        try {
          await decryptSessionObject(entry.stored, pass);
          modalPassword.style.display = 'none';
          modalPassword.classList.remove('backdrop-blur','backdrop-solid');
          currentWallet = null;
          stopFeePolling();
          showScreen('home');
          showToast('info','Sesión cerrada correctamente',2200);
          pendingAction = null;
          return;
        } catch (e) {
          modalPassError.textContent = 'Contraseña incorrecta';
          return;
        }
      }

    } catch (e) {
      modalPassError.textContent = e.message || 'Error';
    }
  });

  let revealTimer = null;
  let revealRemaining = 0;
  function openRevealModalDirect(value, title, desc, type) {
    const modal = document.getElementById('modal-reveal');
    const valEl = document.getElementById('reveal-value');
    const titleEl = document.getElementById('reveal-title');
    const descEl = document.getElementById('reveal-desc');
    const countdownEl = document.getElementById('reveal-countdown');

    titleEl.textContent = title;
    descEl.textContent = desc;

    valEl.classList.remove('mnemonic','privkey');
    if (type === 'mnemonic') valEl.classList.add('mnemonic');
    else if (type === 'privkey') valEl.classList.add('privkey');

    valEl.textContent = value;
    valEl.dataset.raw = value;
    valEl.dataset.masked = 'false';
    countdownEl.textContent = 'Se ocultará en 60s';
    revealRemaining = 60;
    modal.style.display = 'flex';
    modal.classList.add('backdrop-blur');

    if (revealTimer) clearInterval(revealTimer);
    revealTimer = setInterval(() => {
      revealRemaining -= 1;
      if (revealRemaining <= 0) {
        clearInterval(revealTimer);
        revealTimer = null;
        valEl.textContent = '****';
        valEl.dataset.masked = 'true';
        countdownEl.textContent = 'Contenido oculto';
      } else {
        countdownEl.textContent = 'Se ocultará en ' + revealRemaining + 's';
      }
    }, 1000);
  }

  document.getElementById('reveal-copy').addEventListener('click', async () => {
    const valEl = document.getElementById('reveal-value');
    const raw = valEl.dataset.raw || '';
    if (!raw) { showToast('error','No hay contenido para copiar',2000); return; }
    try { await navigator.clipboard.writeText(raw); showToast('success','Copiado al portapapeles',2000); }
    catch (e) { showToast('error','No se pudo copiar',2000); }
  });

  document.getElementById('reveal-close').addEventListener('click', () => {
    const modal = document.getElementById('modal-reveal');
    modal.style.display = 'none';
    modal.classList.remove('backdrop-blur','backdrop-solid');
    if (revealTimer) { clearInterval(revealTimer); revealTimer = null; }
    const valEl = document.getElementById('reveal-value');
    if (valEl) { valEl.dataset.raw = ''; valEl.dataset.masked = 'true'; valEl.textContent = '****'; valEl.classList.remove('mnemonic','privkey'); }
    document.getElementById('reveal-countdown').textContent = '';
  });

  document.getElementById('reveal-value').addEventListener('click', () => {
    const valEl = document.getElementById('reveal-value');
    if (valEl.dataset.masked === 'true') {
      const title = document.getElementById('reveal-title').textContent || '';
      pendingAction = title.toLowerCase().includes('frase') ? 'reveal-mnemonic' : 'reveal-privkey';
      modalTitle.textContent = pendingAction === 'reveal-mnemonic' ? 'Revelar frase' : 'Revelar llave privada';
      modalDesc.textContent = 'Introduce la contraseña de la sesión para mostrar';
      modalSingle.style.display = 'block';
      modalDouble.style.display = 'none';
      modalInput.value = ''; modalPassError.textContent = '';
      modalShowPassword.checked = false;
      modalPassword.style.display = 'flex';
      modalPassword.classList.add('backdrop-blur');
    }
  });

  // Unlock modal and save-warning
  const unlockModal = document.getElementById('modal-unlock');
  const unlockPass = document.getElementById('unlock-pass');
  const unlockShow = document.getElementById('unlock-show-pass');
  const unlockError = document.getElementById('unlock-error');
  const unlockConfirm = document.getElementById('unlock-confirm');
  const unlockCancel = document.getElementById('unlock-cancel');

  const saveWarningModal = document.getElementById('modal-save-warning');
  const saveWarningAccept = document.getElementById('save-warning-accept');

  const exitConfirmFromUnlock = document.getElementById('modal-exit-confirm-from-unlock');
  const exitFromUnlockConfirm = document.getElementById('exit-from-unlock-confirm');
  const exitFromUnlockCancel = document.getElementById('exit-from-unlock-cancel');

  function maskSensitiveImmediately() {
    const valEl = document.getElementById('reveal-value');
    const countdownEl = document.getElementById('reveal-countdown');
    if (valEl) {
      valEl.dataset.raw = '';
      valEl.dataset.masked = 'true';
      valEl.textContent = '****';
      valEl.classList.remove('mnemonic','privkey');
    }
    if (countdownEl) countdownEl.textContent = 'Contenido oculto';
    if (revealTimer) { clearInterval(revealTimer); revealTimer = null; }

    if (currentWallet) {
      const entry = findSessionEntryByAddress(currentWallet.address);
      if (entry) {
        unlockPass.value = '';
        unlockError.textContent = '';
        unlockShow.checked = false;
        unlockPass.type = 'password';
        unlockModal.style.display = 'flex';
        unlockModal.classList.add('backdrop-blur');
        return;
      }
    }

    const activeScreen = document.querySelector('.screen.active');
    const activeId = activeScreen ? activeScreen.id : '';
    if (currentWallet && !findSessionEntryByAddress(currentWallet.address) && activeId === 'screen-wallet') {
      saveWarningModal.style.display = 'flex';
      saveWarningModal.classList.add('backdrop-blur');
      return;
    }
  }

  unlockShow.addEventListener('change', () => { unlockPass.type = unlockShow.checked ? 'text' : 'password'; });

  unlockCancel.addEventListener('click', () => {
    unlockModal.style.display = 'none';
    unlockModal.classList.remove('backdrop-blur','backdrop-solid');
    exitConfirmFromUnlock.style.display = 'flex';
    exitConfirmFromUnlock.classList.add('backdrop-blur');
  });

  function closeUnlockModal() {
    unlockModal.style.display = 'none';
    unlockModal.classList.remove('backdrop-blur','backdrop-solid');
  }

  unlockConfirm.addEventListener('click', async () => {
    const pass = unlockPass.value;
    unlockError.textContent = '';
    if (!pass) { unlockError.textContent = 'Ingresa la contraseña.'; return; }
    const entry = findSessionEntryByAddress(currentWallet.address);
    if (!entry) { unlockError.textContent = 'No hay sesión guardada.'; return; }
    try {
      await decryptSessionObject(entry.stored, pass);
      closeUnlockModal();
      showToast('success','Sesión desbloqueada',2000);
      loadAndRenderBalance(currentWallet.address);
      updateNetworkFee();
    } catch (e) {
      unlockError.textContent = 'Contraseña incorrecta';
    }
  });

  exitFromUnlockConfirm.addEventListener('click', () => {
    exitConfirmFromUnlock.style.display = 'none';
    exitConfirmFromUnlock.classList.remove('backdrop-blur','backdrop-solid');
    closeUnlockModal();
    currentWallet = null;
    stopFeePolling();
    showScreen('home');
    showToast('info','Sesión cerrada. Volviendo al inicio.',2500);
  });

  exitFromUnlockCancel.addEventListener('click', () => {
    exitConfirmFromUnlock.style.display = 'none';
    exitFromUnlockCancel.classList.remove('backdrop-blur','backdrop-solid');
    unlockPass.value = '';
    unlockError.textContent = '';
    unlockShow.checked = false;
    unlockPass.type = 'password';
    unlockModal.style.display = 'flex';
    unlockModal.classList.add('backdrop-blur');
  });

  saveWarningAccept.addEventListener('click', () => {
    saveWarningModal.style.display = 'none';
    saveWarningModal.classList.remove('backdrop-blur','backdrop-solid');
  });

  document.getElementById('modal-close-no-save').addEventListener('click', () => {
    const confirmCloseModal = document.getElementById('modal-confirm-close');
    confirmCloseModal.style.display = 'none';
    confirmCloseModal.classList.remove('backdrop-blur','backdrop-solid');
    currentWallet = null;
    showScreen('home');
    showToast('info','Wallet cerrada sin guardar. Si no guardaste la sesión no podrás recuperarla.',6000);
    stopFeePolling();
  });

  document.getElementById('modal-save-now').addEventListener('click', () => {
    const confirmCloseModal = document.getElementById('modal-confirm-close');
    confirmCloseModal.style.display = 'none';
    confirmCloseModal.classList.remove('backdrop-blur','backdrop-solid');
    pendingAction = 'save';
    modalTitle.textContent = 'Guardar sesión';
    modalDesc.textContent = 'Introduce una contraseña para encriptar y guardar la sesión';
    modalSingle.style.display = 'none';
    modalDouble.style.display = 'block';
    modalInput.value = ''; modalNew.value = ''; modalNewConfirm.value = ''; modalPassError.textContent = '';
    modalShowPassword.checked = false;
    modalPassword.style.display = 'flex';
    modalPassword.classList.add('backdrop-blur');
  });

  document.getElementById('modal-close-cancel').addEventListener('click', () => {
    const confirmCloseModal = document.getElementById('modal-confirm-close');
    confirmCloseModal.style.display = 'none';
    confirmCloseModal.classList.remove('backdrop-blur','backdrop-solid');
  });

  document.addEventListener('visibilitychange', () => { if (document.hidden) maskSensitiveImmediately(); });
  window.addEventListener('blur', () => maskSensitiveImmediately());
  window.addEventListener('pagehide', () => maskSensitiveImmediately());

  document.getElementById('btn-wallet-back').addEventListener('click', () => {
    if (!currentWallet) { showScreen('home'); return; }
    const entry = findSessionEntryByAddress(currentWallet.address);
    if (entry) {
      pendingAction = 'close-session';
      modalTitle.textContent = 'Confirmar cierre';
      modalDesc.textContent = 'Introduce la contraseña de la sesión para cerrar la wallet';
      modalSingle.style.display = 'block';
      modalDouble.style.display = 'none';
      modalInput.value = ''; modalPassError.textContent = '';
      modalShowPassword.checked = false;
      modalPassword.style.display = 'flex';
      modalPassword.classList.add('backdrop-blur');
    } else {
      const confirmCloseModal = document.getElementById('modal-confirm-close');
      confirmCloseModal.style.display = 'flex';
      confirmCloseModal.classList.add('backdrop-blur');
    }
  });

  // Change password flow
  const changeModal = document.getElementById('modal-change-password');
  const changeCurrent = document.getElementById('change-current-pass');
  const changeNew = document.getElementById('change-new-pass');
  const changeNewConfirm = document.getElementById('change-new-pass-confirm');
  const changeShow = document.getElementById('change-show-password');
  const changeError = document.getElementById('change-pass-error');
  const changeConfirmBtn = document.getElementById('change-pass-confirm');
  const changeCancelBtn = document.getElementById('change-pass-cancel');

  document.getElementById('btn-change-password').addEventListener('click', () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',3000); return; }
    const entry = findSessionEntryByAddress(currentWallet.address);
    if (!entry) { showToast('error','No hay sesión guardada para esta wallet',3000); return; }
    changeCurrent.value = '';
    changeNew.value = '';
    changeNewConfirm.value = '';
    changeShow.checked = false;
    changeCurrent.type = 'password';
    changeNew.type = 'password';
    changeNewConfirm.type = 'password';
    changeError.textContent = '';
    changeModal.style.display = 'flex';
    changeModal.classList.add('backdrop-blur');
  });

  changeShow.addEventListener('change', () => {
    const show = changeShow.checked;
    changeCurrent.type = show ? 'text' : 'password';
    changeNew.type = show ? 'text' : 'password';
    changeNewConfirm.type = show ? 'text' : 'password';
  });

  changeCancelBtn.addEventListener('click', () => {
    changeModal.style.display = 'none';
    changeModal.classList.remove('backdrop-blur','backdrop-solid');
    changeError.textContent = '';
  });

  changeConfirmBtn.addEventListener('click', async () => {
    changeError.textContent = '';
    try {
      const cur = changeCurrent.value.trim();
      const nw = changeNew.value.trim();
      const nwc = changeNewConfirm.value.trim();
      if (!cur) { changeError.textContent = 'Ingresa la contraseña actual.'; return; }
      if (!nw || nw.length < 6) { changeError.textContent = 'La nueva contraseña debe tener al menos 6 caracteres.'; return; }
      if (nw !== nwc) { changeError.textContent = 'Las nuevas contraseñas no coinciden.'; return; }

      const entry = findSessionEntryByAddress(currentWallet.address);
      if (!entry) { changeError.textContent = 'No hay sesión guardada para esta wallet.'; return; }

      let payload;
      try {
        payload = await decryptSessionObject(entry.stored, cur);
      } catch (e) {
        changeError.textContent = 'Contraseña actual incorrecta.';
        return;
      }

      const newStored = await encryptSessionObject(payload, nw);
      const updatedEntry = Object.assign({}, entry, { stored: newStored });
      const ok = updateSessionEntry(updatedEntry);
      if (!ok) { changeError.textContent = 'No se pudo actualizar la sesión.'; return; }

      changeModal.style.display = 'none';
      changeModal.classList.remove('backdrop-blur','backdrop-solid');
      showToast('success','Contraseña actualizada correctamente',3000);
      renderSavedList();
      updateSaveButtonState();
    } catch (e) {
      changeError.textContent = e.message || 'Error al cambiar contraseña';
    }
  });

  // RPCs modal flow
  const rpcsModal = document.getElementById('modal-rpcs');
  const rpcsInput = document.getElementById('rpcs-input');
  const rpcsAddBtn = document.getElementById('rpcs-add');
  const rpcsClearBtn = document.getElementById('rpcs-clear');
  const rpcsCloseBtn = document.getElementById('rpcs-close');
  const rpcsBtn = document.getElementById('btn-rpcs');

  rpcsBtn.addEventListener('click', () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',2000); return; }
    rpcsInput.value = '';
    renderRpcListUi();
    rpcsModal.style.display = 'flex';
    rpcsModal.classList.add('backdrop-blur');
  });

  rpcsCloseBtn.addEventListener('click', () => {
    rpcsModal.style.display = 'none';
    rpcsModal.classList.remove('backdrop-blur','backdrop-solid');
  });

  rpcsClearBtn.addEventListener('click', () => {
    rpcsInput.value = '';
  });

  rpcsAddBtn.addEventListener('click', async () => {
    const raw = rpcsInput.value.trim();
    if (!raw) { showToast('error','Introduce al menos un RPC',2000); return; }
    const parts = raw.split(/[,;]+/).map(s => s.trim()).filter(Boolean);
    if (!parts.length) { showToast('error','No se detectaron RPCs válidos',2000); return; }
    const valid = parts.filter(p => /^https?:\/\//i.test(p));
    if (!valid.length) { showToast('error','Los RPCs deben comenzar con http:// o https://',3000); return; }
    valid.forEach(p => { if (!rpcList.includes(p)) rpcList.push(p); });
    saveRpcs(rpcList);
    await pickBestRpcAndCreateProvider();
    renderRpcListUi();
    rpcsInput.value = '';
    showToast('success','RPCs añadidos y activos',1500);
  });

  // Rescan optimized
  async function getLastScannedBlock(address) {
    try {
      const raw = localStorage.getItem(LAST_SCANNED_KEY);
      if (!raw) return null;
      const map = JSON.parse(raw);
      return map && map[address.toLowerCase()] ? Number(map[address.toLowerCase()]) : null;
    } catch { return null; }
  }
  async function setLastScannedBlock(address, blockNumber) {
    try {
      const raw = localStorage.getItem(LAST_SCANNED_KEY);
      const map = raw ? JSON.parse(raw) : {};
      map[address.toLowerCase()] = Number(blockNumber);
      localStorage.setItem(LAST_SCANNED_KEY, JSON.stringify(map));
    } catch (e) {}
  }

  async function rescanRecentBlocks(count = 200) {
    if (!currentWallet) { showToast('error','No hay wallet activa',2000); return; }
    try {
      await pickBestRpcAndCreateProvider();
      showToast('info','Iniciando re-scan de bloques recientes...',2000);
      const latest = await provider.getBlockNumber();
      let lastScanned = await getLastScannedBlock(currentWallet.address);
      if (!lastScanned) lastScanned = Math.max(0, latest - count);
      const from = Math.max(0, lastScanned + 1);
      const to = latest;
      if (from > to) { showToast('info','No hay bloques nuevos para escanear',2000); return; }

      const loader = showLoadingModalControlled('Re-scaneando historial...', Math.min(30000, (to - from + 1) * 50));
      const blocks = [];
      for (let b = from; b <= to; b++) blocks.push(b);

      let processed = 0;
      const concurrency = 6;
      const chunks = [];
      for (let i = 0; i < blocks.length; i += concurrency) chunks.push(blocks.slice(i, i + concurrency));
      for (const ch of chunks) {
        await Promise.all(ch.map(b => provider.getBlockWithTransactions(b).then(block => {
          if (block && Array.isArray(block.transactions)) {
            for (const tx of block.transactions) {
              if (!tx.to && !tx.from) continue;
              const addrLower = currentWallet.address.toLowerCase();
              if ((tx.to && tx.to.toLowerCase() === addrLower) || (tx.from && tx.from.toLowerCase() === addrLower)) {
                provider.getTransactionReceipt(tx.hash).then(receipt => {
                  let feeStr = null;
                  if (receipt && receipt.gasUsed) {
                    const effective = receipt.effectiveGasPrice || receipt.gasPrice || ethers.BigNumber.from(0);
                    const feeWei = receipt.gasUsed.mul(effective);
                    feeStr = ethers.utils.formatUnits(feeWei, 18);
                  }
                  const txObj = {
                    hash: tx.hash,
                    from: tx.from,
                    to: tx.to,
                    value: ethers.utils.formatUnits(tx.value || '0', 18),
                    blockNumber: block.number,
                    timestamp: block.timestamp || Math.floor(Date.now()/1000),
                    status: 'confirmed',
                    fee: feeStr
                  };
                  pushTxToHistory(currentWallet.address, txObj);
                }).catch(()=>{});
              }
            }
          }
          processed++;
          const pct = Math.round((processed / blocks.length) * 100);
          loader.setProgress(pct);
        }).catch(()=>{ processed++; const pct = Math.round((processed / blocks.length) * 100); loader.setProgress(pct); })));
      }

      await setLastScannedBlock(currentWallet.address, latest);
      loader.stop();
      renderTxHistoryUI();
      showToast('success','Re-scan completado',2500);
    } catch (e) {
      showToast('error','Error durante re-scan',3000);
    }
  }

  document.getElementById('btn-rescan-history')?.addEventListener('click', () => {
    if (!currentWallet) { showToast('error','No hay wallet activa',2000); return; }
    rescanRecentBlocks(200);
  });

  // Initialize UI
  renderSavedList();
  renderRpcListUi();
  updateSaveButtonState();
  (async () => { await pickBestRpcAndCreateProvider(); })();

  // Expose recover helper
  window.openRecoverInline = (id) => openRecoverInline(id);
});
</script>
</body>
</html>
